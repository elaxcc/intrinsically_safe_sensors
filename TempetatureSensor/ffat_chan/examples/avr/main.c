/*----------------------------------------------------------------------*/
/* FAT file system sample project for FatFs R0.04a  (C)ChaN, 2007       */
/*----------------------------------------------------------------------*/


#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <string.h>
#include "uart.h"
#include "xitoa.h"
#include "stime.h"
#include "ff.h"
#include "diskio.h"



DWORD acc_size;				/* Work register for fs command */
WORD acc_files, acc_dirs;
FILINFO finfo;

BYTE linebuf[120];			/* Console input buffer */

FATFS fatfs[2];				/* File system object for each logical drive */
BYTE Buff[1024];			/* Working buffer */


volatile WORD Timer;		/* 100Hz increment timer */

time_t rtc = 1144713600;	/* Real Time Clock (start at 2006/4/11) */


#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1} };
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/


ISR(TIMER2_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}



/*---------------------------------------------------------*/
/* 1 Hz timer interrupt generated by OC0                   */
/*---------------------------------------------------------*/


ISR(TIMER0_COMP_vect)
{
	rtc++;
}



/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */


DWORD get_fattime ()
{
	struct tm *tmr;
	time_t t;


	cli();
	t = rtc;
	sei();
	tmr = gmtime(&t);
	return	  ((DWORD)(tmr->tm_year - 80) << 25)
			| ((DWORD)(tmr->tm_mon + 1) << 21)
			| ((DWORD)tmr->tm_mday << 16)
			| (WORD)(tmr->tm_hour << 11)
			| (WORD)(tmr->tm_min << 5)
			| (WORD)(tmr->tm_sec >> 1);
/*
	return	((2006UL-1980) << 25)	// Year = 2006
			| (2UL << 21)			// Month = Feb
			| (9UL << 16)			// Day = 9
			| (22U << 11)			// Hour = 22
			| (30U << 5)			// Min = 30
			| (0U >> 1)				// Sec = 0
			;
*/
}


/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */


static
void put_dump (const BYTE *buff, uint32_t ofs, BYTE cnt)
{
	BYTE n;


	xprintf(PSTR("\n%08lX "), ofs);
	for(n = 0; n < cnt; n++)
		xprintf(PSTR(" %02X"), buff[n]);
	xputc(' ');
	for(n = 0; n < cnt; n++) {
		if ((buff[n] < 0x20)||(buff[n] >= 0x7F))
			xputc('.');
		else
			xputc(buff[n]);
	}
}


static
void get_line (char *buff, int len)
{
	char c;
	int idx = 0;


	for (;;) {
		c = uart_get();
		if (c == '\r') break;
		if ((c == '\b') && idx) {
			idx--; uart_put(c);
		}
		if (((BYTE)c >= ' ') && (idx < len - 1)) {
				buff[idx++] = c; uart_put(c);
		}
	}
	buff[idx] = 0;
	uart_put(c);
}


static
FRESULT scan_files (char* path)
{
	DIR dirs;
	FRESULT res;
	int i;


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
		i = strlen(path);
		while (((res = f_readdir(&dirs, &finfo)) == FR_OK) && finfo.fname[0]) {
			if (finfo.fattrib & AM_DIR) {
				acc_dirs++;
				*(path+i) = '/'; strcpy(path+i+1, &finfo.fname[0]);
				res = scan_files(path);
				*(path+i) = '\0';
				if (res != FR_OK) break;
			} else {
				acc_files++;
				acc_size += finfo.fsize;
			}
		}
	}

	return res;
}



static
void put_rc (FRESULT rc)
{
	const prog_char *p;
	static const prog_char str[] =
		"OK\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
		while(pgm_read_byte_near(p++));
	}
	xprintf(PSTR("\nrc=%u FR_%S"), (WORD)rc, p);
}




static
void IoInit ()
{
	PORTA = 0b11111111;	// Port A

	PORTB = 0b10110000; // Port B
	DDRB  = 0b11000000;

	PORTC = 0b11111111;	// Port C

	PORTD = 0b11111111; // Port D

	PORTE = 0b11111110; // Port E
	DDRE  = 0b10000010;

	PORTF = 0b11111111;	// Port F

	PORTG = 0b00111; 	// Port G

	uart_init();		// Initialize UART driver

	ASSR = 0b00001000;	// Timer0: 1Hz async operation (OC0)
	OCR0 = 128-1;
	TCCR0 = 0b0001110;
/*
	OCR1A = 51;			// Timer1: LCD bias generator (OC1B)
	OCR1B = 51;
	TCCR1A = 0b00010000;
	TCCR1B = 0b00001010;
*/
	OCR2 = 90-1;		// Timer2: 100Hz interval (OC2)
	TCCR2 = 0b00001101;

	TIMSK = 0b10000010;	// Enable TC2.oc, TC0.oc interrupt

	sei();
}



/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main ()
{
	char *ptr, *ptr2;
	DWORD p1, p2, p3;
	BYTE res, b1;
	WORD w1;
	UINT s1, s2, cnt, blen = sizeof(Buff);
	DWORD ofs, sect = 0;
	struct tm *tmr = gmtime(0);
	FATFS *fs;
	DIR dir;				/* Directory object */
	FIL file1, file2;		/* File object */


	IoInit();

	/* Join xitoa module to uart module */
	xfunc_out = (void (*)(char))uart_put;

	xputs(PSTR("\nFatFs module test monitor"));

	for (;;) {
		xputs(PSTR("\n>"));
		ptr = linebuf;
		get_line(ptr, sizeof(linebuf));

		switch (*ptr++) {

		case 'd' :
			switch (*ptr++) {
			case 'd' :	/* dd <phy_drv#> [<sector>] - Dump secrtor */
				if (!xatoi(&ptr, &p1)) break;
				if (!xatoi(&ptr, &p2)) p2 = sect;
				res = disk_read((BYTE)p1, Buff, p2, 1);
				if (res) { xprintf(PSTR("\nrc=%d"), (WORD)res); break; }
				sect = p2 + 1;
				xprintf(PSTR("\nSector:%lu"), p2);
				for (ptr=Buff, ofs = 0; ofs < 0x200; ptr+=16, ofs+=16)
					put_dump(ptr, ofs, 16);
				break;

			case 'i' :	/* di <phy_drv#> - Initialize disk */
				if (!xatoi(&ptr, &p1)) break;
				xprintf(PSTR("\nrc=%d"), (WORD)disk_initialize((BYTE)p1));
				break;

			case 's' :	/* ds <phy_drv#> - Show disk status */
				if (!xatoi(&ptr, &p1)) break;
				if (disk_ioctl((BYTE)p1, GET_SECTOR_COUNT, &p2) == RES_OK)
					{ xprintf(PSTR("\nDrive size: %lu sectors"), p2); }
				if (disk_ioctl((BYTE)p1, GET_SECTOR_SIZE, &w1) == RES_OK)
					{ xprintf(PSTR("\nSector size: %u"), w1); }
				if (disk_ioctl((BYTE)p1, GET_BLOCK_SIZE, &p2) == RES_OK)
					{ xprintf(PSTR("\nErase block size: %lu sectors"), p2); }
				if (disk_ioctl((BYTE)p1, MMC_GET_TYPE, &b1) == RES_OK)
					{ xprintf(PSTR("\nMMC/SDC type: %u"), b1); }
				if (disk_ioctl((BYTE)p1, MMC_GET_CSD, Buff) == RES_OK)
					{ xputs(PSTR("\nCSD:")); put_dump(Buff, 0, 16); }
				if (disk_ioctl((BYTE)p1, MMC_GET_CID, Buff) == RES_OK)
					{ xputs(PSTR("\nCID:")); put_dump(Buff, 0, 16); }
				if (disk_ioctl((BYTE)p1, MMC_GET_OCR, Buff) == RES_OK)
					{ xputs(PSTR("\nOCR:")); put_dump(Buff, 0, 4); }
				if (disk_ioctl((BYTE)p1, MMC_GET_SDSTAT, Buff) == RES_OK) {
					xputs(PSTR("\nSD Status:"));
					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16);
				}
				if (disk_ioctl((BYTE)p1, ATA_GET_MODEL, linebuf) == RES_OK)
					{ linebuf[40] = '\0'; xprintf(PSTR("\nModel: %s"), linebuf); }
				if (disk_ioctl((BYTE)p1, ATA_GET_SN, linebuf) == RES_OK)
					{ linebuf[20] = '\0'; xprintf(PSTR("\nS/N: %s"), linebuf); }
				break;
			}
			break;

		case 'b' :
			switch (*ptr++) {
			case 'd' :	/* bd <addr> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				for (ptr=&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
					put_dump(ptr, ofs, 16);
				break;

			case 'e' :	/* be <addr> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				if (xatoi(&ptr, &p2)) {
					do {
						Buff[p1++] = (BYTE)p2;
					} while (xatoi(&ptr, &p2));
					break;
				}
				for (;;) {
					xprintf(PSTR("\n%04X %02X-"), (WORD)(p1), (WORD)Buff[p1]);
					get_line(linebuf, sizeof(linebuf));
					ptr = linebuf;
					if (*ptr == '.') break;
					if (*ptr < ' ') { p1++; continue; }
					if (xatoi(&ptr, &p2))
						Buff[p1++] = (BYTE)p2;
					else
						xputs(PSTR("\n???"));
				}
				break;

			case 'r' :	/* br <phy_drv#> <sector> [<n>] - Read disk into R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				if (!xatoi(&ptr, &p2)) break;
				if (!xatoi(&ptr, &p3)) p3 = 1;
				xprintf(PSTR("\nrc=%u"), (WORD)disk_read((BYTE)p1, Buff, p2, p3));
				break;

			case 'w' :	/* bw <phy_drv#> <sector> [<n>] - Write R/W buffer into disk */
				if (!xatoi(&ptr, &p1)) break;
				if (!xatoi(&ptr, &p2)) break;
				if (!xatoi(&ptr, &p3)) p3 = 1;
				xprintf(PSTR("\nrc=%u"), (WORD)disk_write((BYTE)p1, Buff, p2, p3));
				break;

			case 'f' :	/* bf <n> - Fill working buffer */
				if (!xatoi(&ptr, &p1)) break;
				memset(Buff, (BYTE)p1, sizeof(Buff));
				break;

			}
			break;

		case 'f' :
			switch (*ptr++) {

			case 'i' :	/* fi <log drv#> - Initialize logical drive */
				if (!xatoi(&ptr, &p1)) break;
				put_rc(f_mount((BYTE)p1, &fatfs[p1]));
				break;

			case 's' :	/* fs [<path>] - Show logical drive status */
				res = f_getfree(ptr, &p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf(PSTR("\nFAT type = %u\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
							 "Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
							 "FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n"),
						(WORD)fs->fs_type, (DWORD)fs->sects_clust * 512, (WORD)fs->n_fats,
						fs->n_rootdir, (DWORD)fs->sects_fat, (DWORD)fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf(PSTR("\n%u files, %lu bytes.\n%u folders.\n"
							 "%lu KB total disk space.\n%lu KB available."),
						acc_files, acc_size, acc_dirs,
						(fs->max_clust - 2) * (fs->sects_clust / 2), p2 * (fs->sects_clust / 2)
				);
				break;

			case 'l' :	/* fl [<path>] - Directory listing */
				res = f_opendir(&dir, ptr);
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
					res = f_readdir(&dir, &finfo);
					if ((res != FR_OK) || !finfo.fname[0]) break;
					if (finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += finfo.fsize;
					}
					xprintf(PSTR("\n%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s"), 
								(finfo.fattrib & AM_DIR) ? 'D' : '-',
								(finfo.fattrib & AM_RDO) ? 'R' : '-',
								(finfo.fattrib & AM_HID) ? 'H' : '-',
								(finfo.fattrib & AM_SYS) ? 'S' : '-',
								(finfo.fattrib & AM_ARC) ? 'A' : '-',
								(finfo.fdate >> 9) + 1980, (finfo.fdate >> 5) & 15, finfo.fdate & 31,
								(finfo.ftime >> 11), (finfo.ftime >> 5) & 63,
								finfo.fsize, &(finfo.fname[0]));
				}
				xprintf(PSTR("\n%4u File(s),%10lu bytes total\n%4u Dir(s)"), s1, p1, s2);
				if (f_getfree(ptr, &p1, &fs) == FR_OK)
					xprintf(PSTR(", %10luK bytes free"), p1 * fs->sects_clust / 2);
				break;

			case 'o' :	/* fo <mode> <name> - Open a file */
				if (!xatoi(&ptr, &p1)) break;
				put_rc(f_open(&file1, ptr, (BYTE)p1));
				break;

			case 'c' :	/* fc - Close a file */
				put_rc(f_close(&file1));
				break;

			case 'e' :	/* fe - Seek file pointer */
				if (!xatoi(&ptr, &p1)) break;
				res = f_lseek(&file1, p1);
				put_rc(res);
				if (res == FR_OK)
					xprintf(PSTR("\nfptr = %lu(0x%lX)"), file1.fptr, file1.fptr);
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
					if (p1 >= blen)	{ cnt = blen; p1 -= blen; }
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_read(&file1, Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				s2 = Timer;
				xprintf(PSTR("\n%lu bytes read with %lu bytes/sec."), p2, p2 * 100 / s2);
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = file1.fptr;
				while (p1) {
					if (p1 >= 16)	{ cnt = 16; p1 -= 16; }
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_read(&file1, Buff, cnt, &cnt);
					if (res != FR_OK) { put_rc(res); break; }
					if (!cnt) break;
					put_dump(Buff, ofs, cnt);
					ofs += 16;
				}
				break;

			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, blen);
				p2 = 0;
				Timer = 0;
				while (p1) {
					if (p1 >= blen)	{ cnt = blen; p1 -= blen; }
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_write(&file1, Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				s2 = Timer;
				xprintf(PSTR("\n%lu bytes written with %lu bytes/sec."), p2, p2 * 100 / s2);
				break;

			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				while (*ptr2 == ' ') ptr2++;
				put_rc(f_rename(ptr, ptr2));
				break;

			case 'u' :	/* fu <name> - Unlink a file or dir */
				put_rc(f_unlink(ptr));
				break;

			case 'k' :	/* fk <name> - Create a directory */
				put_rc(f_mkdir(ptr));
				break;

			case 'a' :	/* fa <atrr> <mask> <name> - Change file/dir attribute */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				put_rc(f_chmod(ptr, p1, p2));
				break;

			case 'x' : /* fx <src_name> <dst_name> - Copy file */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				xprintf(PSTR("\nOpening \"%s\""), ptr);
				res = f_open(&file1, ptr, FA_OPEN_EXISTING | FA_READ);
				if (res) {
					put_rc(res);
					break;
				}
				xprintf(PSTR("\nCreating \"%s\""), ptr2);
				res = f_open(&file2, ptr2, FA_CREATE_ALWAYS | FA_WRITE);
				if (res) {
					put_rc(res);
					f_close(&file1);
					break;
				}
				xprintf(PSTR("\nCopying..."));
				p1 = 0;
				for (;;) {
					res = f_read(&file1, Buff, sizeof(Buff), &s1);
					if (res || s1 == 0) break;   /* error or eof */
					res = f_write(&file2, Buff, s1, &s2);
					p1 += s2;
					if (res || s2 < s1) break;   /* error or disk full */
				}
				xprintf(PSTR("\n%lu bytes copied."), p1);
				f_close(&file1);
				f_close(&file2);
				break;
#if _USE_MKFS
			case 'm' :	/* fm <logi drv#> <part type> <bytes/clust> - Create file system */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				xprintf(PSTR("\nThe drive %u will be formatted. Are you sure? (Y/n)="), (WORD)p1);
				get_line(ptr, sizeof(linebuf));
				if (*ptr == 'Y') put_rc(f_mkfs((BYTE)p1, (BYTE)p2, (WORD)p3));
				break;
#endif
			case 'z' :	/* fz <len> - set transfer unit for fr/fw commands */
				if (xatoi(&ptr, &p1) && (p1 > 0) && (p1 <= sizeof(Buff)))
					blen = (WORD)p1;
				xprintf(PSTR("\nlen=%u"), blen);
				break;
			}
			break;

		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			if (xatoi(&ptr, &p1)) {
				tmr->tm_year = p1-1900;
				xatoi(&ptr, &p1); tmr->tm_mon = p1-1;
				xatoi(&ptr, &p1); tmr->tm_mday = p1;
				xatoi(&ptr, &p1); tmr->tm_hour = p1;
				xatoi(&ptr, &p1); tmr->tm_min = p1;
				if(!xatoi(&ptr, &p1)) break;
				tmr->tm_sec = p1;
				rtc = mktime(tmr);
			}
			tmr = gmtime(&rtc);
			xprintf(PSTR("\n%u/%u/%u %02u:%02u:%02u"), tmr->tm_year+1900, tmr->tm_mon+1, tmr->tm_mday, tmr->tm_hour, tmr->tm_min, tmr->tm_sec);
			break;
		}
	}

}


